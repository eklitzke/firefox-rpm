# HG changeset patch
# Parent cef590a6f94681064fa954890bae6014db819158
# User Martin Stransky <stransky@redhat.com>
Bug 1073117 - Add new GTK_STATE_FLAG_CHECKED for checkbox rendering, r=?karlt

diff --git a/widget/gtk/gtk3drawing.c b/widget/gtk/gtk3drawing.c
--- a/widget/gtk/gtk3drawing.c
+++ b/widget/gtk/gtk3drawing.c
@@ -59,23 +59,28 @@ static GtkWidget* gExpanderWidget;
 static GtkWidget* gToolbarSeparatorWidget;
 static GtkWidget* gMenuSeparatorWidget;
 static GtkWidget* gHPanedWidget;
 static GtkWidget* gVPanedWidget;
 static GtkWidget* gScrolledWindowWidget;
 
 static style_prop_t style_prop_func;
 static gboolean have_arrow_scaling;
+static gboolean checkbox_check_state;
 static gboolean is_initialized;
 
 #define ARROW_UP      0
 #define ARROW_DOWN    G_PI
 #define ARROW_RIGHT   G_PI_2
 #define ARROW_LEFT    (G_PI+G_PI_2)
 
+#if !GTK_CHECK_VERSION(3,14,0)
+#define GTK_STATE_FLAG_CHECKED (1 << 11)
+#endif
+
 static GtkStateFlags
 GetStateFlagsFromGtkWidgetState(GtkWidgetState* state)
 {
     GtkStateFlags stateFlags = GTK_STATE_FLAG_NORMAL;
 
     if (state->disabled)
         stateFlags = GTK_STATE_FLAG_INSENSITIVE;
     else {    
@@ -709,17 +714,22 @@ moz_gtk_init()
     GtkWidgetClass *entry_class;
 
     if (is_initialized)
         return MOZ_GTK_SUCCESS;
 
     is_initialized = TRUE;
     have_arrow_scaling = (gtk_major_version > 2 ||
                           (gtk_major_version == 2 && gtk_minor_version >= 12));
-
+    if (gtk_major_version > 3 ||
+       (gtk_major_version == 3 && gtk_minor_version >= 14))
+        checkbox_check_state = GTK_STATE_FLAG_CHECKED;
+    else
+        checkbox_check_state = GTK_STATE_FLAG_ACTIVE;
+
     /* Add style property to GtkEntry.
      * Adding the style property to the normal GtkEntry class means that it
      * will work without issues inside GtkComboBox and for Spinbuttons. */
     entry_class = g_type_class_ref(GTK_TYPE_ENTRY);
 
     return MOZ_GTK_SUCCESS;
 }
 
@@ -999,20 +1009,20 @@ moz_gtk_toggle_paint(cairo_t *cr, GdkRec
     focus_width = width + 2 * indicator_spacing;
     focus_height = height + 2 * indicator_spacing;
   
     style = gtk_widget_get_style_context(w);
 
     gtk_widget_set_sensitive(w, !state->disabled);
     gtk_widget_set_direction(w, direction);
     gtk_style_context_save(style);
-      
+
     if (isradio) {
         gtk_style_context_add_class(style, GTK_STYLE_CLASS_RADIO);
-        gtk_style_context_set_state(style, selected ? GTK_STATE_FLAG_ACTIVE :
+        gtk_style_context_set_state(style, selected ? checkbox_check_state :
                                                       GTK_STATE_FLAG_NORMAL);
         gtk_render_option(style, cr, x, y, width, height);
         if (state->focused) {
             gtk_render_focus(style, cr, focus_x, focus_y,
                             focus_width, focus_height);
         }
     }
     else {
@@ -1020,17 +1030,17 @@ moz_gtk_toggle_paint(cairo_t *cr, GdkRec
         * 'indeterminate' type on checkboxes. In GTK, the shadow type
         * must also be changed for the state to be drawn.
         */        
         gtk_style_context_add_class(style, GTK_STYLE_CLASS_CHECK);
         if (inconsistent) {
             gtk_style_context_set_state(style, GTK_STATE_FLAG_INCONSISTENT);
             gtk_toggle_button_set_inconsistent(GTK_TOGGLE_BUTTON(gCheckboxWidget), TRUE);
         } else if (selected) {
-            gtk_style_context_set_state(style, GTK_STATE_FLAG_ACTIVE);
+            gtk_style_context_set_state(style, checkbox_check_state);
         } else {
             gtk_toggle_button_set_inconsistent(GTK_TOGGLE_BUTTON(gCheckboxWidget), FALSE);
         }
         gtk_render_check(style, cr, x, y, width, height);        
         if (state->focused) {
             gtk_render_focus(style, cr, 
                              focus_x, focus_y, focus_width, focus_height);
         }
@@ -2583,18 +2593,19 @@ moz_gtk_check_menu_item_paint(cairo_t *c
     style = gtk_widget_get_style_context(gCheckMenuItemWidget);
     gtk_style_context_save(style);
     if (isradio) {
       gtk_style_context_add_class(style, GTK_STYLE_CLASS_RADIO);
     } else {
       gtk_style_context_add_class(style, GTK_STYLE_CLASS_CHECK);
     }
 
-    if (checked)
-      state_flags |= GTK_STATE_FLAG_ACTIVE;
+    if (checked) {
+      state_flags |= checkbox_check_state;
+    }
     
     gtk_style_context_set_state(style, state_flags);
     gtk_style_context_get_padding(style, state_flags, &padding);
 
     offset = gtk_container_get_border_width(GTK_CONTAINER(gCheckMenuItemWidget)) +
                                             padding.left + 2;
 
     if (direction == GTK_TEXT_DIR_RTL) {
